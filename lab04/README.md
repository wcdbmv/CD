# Лабораторная работа 4

# Синтаксический анализатор операторного предшествования

## 1. Цель и задачи работы

**Цель работы:** приобретение практических навыков реализации таблично управляемых синтаксических анализаторов на примере анализатора операторного предшествования.

**Задачи работы:**

1. Ознакомиться с основными понятиями и определениями, лежащими в основе синтаксического анализа операторного предшествования.
2. Изучить алгоритм синтаксического анализа операторного предшествования.
3. Разработать, тестировать и отладить программу синтаксического анализа в соответствии с предложенным вариантом грамматики.
4. Включить в программу синтаксического анализ семантические действия для реализации синтаксически управляемого перевода инфиксного выражения в обратную польскую нотацию.

## 2. Материал для изучения и ознакомления

Перед выполнением работы рекомендуется ознакомиться со следующими материалами:

- Wirth–Weber precedence relationship. URL: [http://en.wikipedia.org/wiki/Wirth-Weber_precedence_relationship](http://en.wikipedia.org/wiki/Wirth-Weber_precedence_relationship). (Дата обращения: 05.05.2014).
- Operator-precedence grammar. URL: [http://en.wikipedia.org/wiki/Operator-precedence_grammar](http://en.wikipedia.org/wiki/Operator-precedence_grammar). (Дата обращения: 05.05.2014).
- Operator-precedence parser. URL: [http://en.wikipedia.org/wiki/Operator-precedence_parser](http://en.wikipedia.org/wiki/Operator-precedence_parser). (Дата обращения: 05.05.2014).

## 3. Теоретическая часть

Метод операторного предшествования относится к классу восходящих таблично-управляемых методов синтаксического анализа на основе алгоритма типа «перенос/свертка». Этот метод основан на отношениях предшествования Вирта-Вебера, но только между терминальными символами грамматики.

**Определение 1.** Операторной грамматикой называется приведенная КС-грамматика без $\varepsilon$-правил, в которой правые части правил не содержат смежных нетерминалов.

**Определение 2.** Для операторной грамматики отношения предшествования можно задать на множестве терминалов плюс символ $\\$ $, игнорируя нетерминалы. Пусть $G = (N, \Sigma, P, S)$ — операторная грамматика и $\\$ $ — новый символ. Зададим отношения операторного предшествования на множестве $\Sigma \cup \\{ \\$ \\}$:

1. $\boldsymbol a \doteq \boldsymbol b$, если $A \to \alpha \boldsymbol a \gamma \boldsymbol b \beta \in P$ и $\gamma \in N \cup \\{ \varepsilon \\}$,
2. $\boldsymbol a \lessdot \boldsymbol b$, если $A \to \alpha \boldsymbol a B \beta \in P$ и $B \Rightarrow^+ \gamma \boldsymbol b \delta$, где $\gamma \in N \cup \\{ \varepsilon \\}$,
3. $\boldsymbol a \gtrdot \boldsymbol b$, если $A \to \alpha B \boldsymbol b \beta \in P$ и $B \Rightarrow^+ \delta \boldsymbol a \gamma$, где $\gamma \in N \cup \\{ \varepsilon \\}$,
4. $\\$ \lessdot \boldsymbol a$, если $S \Rightarrow^+ \gamma \boldsymbol a \delta$ и $\gamma \in N \cup \\{ \varepsilon \\}$,
5. $\boldsymbol a \gtrdot \\$ $, если $S \Rightarrow^+ \alpha \boldsymbol a \gamma$ и $\gamma \in N \cup \\{ \varepsilon \\}$.

**Определение 3.** Операторная грамматика $G$ называется грамматикой операторного предшествования, если между любыми двумя терминальными символами выполняется не более одного отношения операторного предшествования.

**Пример 1.** Примером грамматики операторного предшествования служит грамматика $G_0$ с правилами

$$
\begin{align*}
E & \to E + T | T & :1, 2 \\
T & \to T * F | F & :3, 4 \\
F & \to ( E ) | a & :5, 6 \\
\end{align*}
$$

Матрица отношений операторного предшествования для этой грамматики, будет иметь вид

![](https://sun9-north.userapi.com/sun9-85/s/v1/ig2/SZmb-sxdPRpF0maAtkr3AWmyzT6MOv1Lh6NXuCxQ6wLlj8nnnnSkjO1ENmOWy_LL3zD0-KAJRi0lcDe9gBbNOPWz.jpg?size=418x411&quality=96&type=album)

Пустая клетка матрицы интерпретируется как **ошибка**.

Идея синтаксического анализа для грамматик операторного предшествования вытекает из теоремы, которая приводится без доказательства.

**Теорема.** Пусть $G = (N, \Sigma, P, S)$ — операторная грамматика и $\\$S\\$ \Rightarrow^* \alpha A w \Rightarrow \alpha \beta w$. Тогда

1. *отношение операторного предшествования* $\lessdot$ или $\doteq$ *выполняется между последовательными терминалами (и символом* $\\$ $*) цепочки* $\alpha$;
2. *отношение* $\lessdot$ *выполняется между самым правым терминалом цепочки* $\alpha$ *и самым левым терминалом цепочки* $\beta$;
3. *отношение* $\doteq$ *выполняется между последовательными терминалами цепочки* $\beta$;
4. *отношение* $\gtrdot$ *выполняется между самым правым терминалом цепочки* $\beta$ *и первым символом цепочки* $w$.

С помощью алгоритма разбора типа «перенос-свертка» легко выделить терминальные символы, входящие в основу $\beta$. Однако возникают проблемы в связи с нетерминальными символами, поскольку на них не определены отношения операторного предшествования. Тем не менее, тот факт, исходная грамматика является операторной грамматикой, позволяет строить «остовный» правый разбор.

Определение 4. Пусть $G = (N, \Sigma, P, S)$ — операторная грамматика. Остовной грамматикой для $G$ назовем грамматику $G_s = (\\{S\\}, \Sigma, P', S)$, содержащую каждое правило $S \to X_1 X_2 \ldots X_m$, для которого в $P$ найдется такое правило $A \to Y_1 Y_2 \ldots Y_m$, что для $1 \leqslant i \leqslant m$

1. $X_i = Y_i$, если $Y_i \in \Sigma$,
2. $X_i = S$, если $Y_i \in N$.

Но в $P'$ не должно быть правила $S \to S$.

Следует обратить внимание на то, что $L(G) \subseteq L(G_s)$ и, вообще говоря, $L(G_s)$ может содержать цепочки, не принадлежащие $L(G)$. Теперь можно описать алгоритм типа «перенос-свертка» для грамматик операторного предшествования.

**Алгоритм построения анализатора операторного предшествования**
*Вход.* Грамматика операторного предшествования $G = (N, \Sigma, P, S)$.
*Выход.* Алгоритм разбора $A = (f, g)$ типа «перенос-свертка» для грамматики $G_s$.
*Метод.* Пусть $\beta$ обозначает $S$ или $\varepsilon$.

1. $f(\boldsymbol a \beta, \boldsymbol b) =$ **перенос**, если $\boldsymbol a \lessdot \boldsymbol b$ или $\boldsymbol a \doteq \boldsymbol b$.
2. $f(\boldsymbol a \beta, \boldsymbol b) =$ **свертка**, если $\boldsymbol a \gtrdot \boldsymbol b$.
3. $f(\\$ S, \\$) =$ **допуск**.
4. $f(\alpha, w)$ — **ошибка** в остальных случаях.
5. $g(\boldsymbol a \beta \boldsymbol b \gamma, \boldsymbol w) = i$, если
    1. $\beta$ — это $S$ или $\varepsilon$,
    2. $\boldsymbol a \lessdot \boldsymbol b$,
    3. отношение $\doteq$ выполняется между последовательными терминальными символами цепочки $\gamma$, если они существуют,
    4. $S \to \beta \boldsymbol b \gamma$ — правило с номером $i$ грамматики $G_s$.
6. $g(\alpha, w)$ — **ошибка** в остальных случаях.

**Пример 2.** Выполнить разбор цепочки $(\boldsymbol a + \boldsymbol a) * \boldsymbol a$ в соответствии с отношениями операторного предшествования для грамматики $G_0$. Остовной грамматикой для $G_0$ будет грамматика $G_{0s}$ с правилами $E \to E + E | E * E | ( E ) | \boldsymbol a$, полученная из $G_0$ заменой всех нетерминалов символом $E$ и устранением всех цепных правил. (Заметим, что в операторной грамматике правилом, не содержащим терминалов в правой части, может быть только цепное правило). Грамматика $G_{0s}$, очевидно, не однозначная, но отношения операторного предшествования гарантируют единственность искомого разбора. Алгоритм разбора $A$ для грамматики $G$ задается определяемыми ниже функциями $f$ и $g$. Цепочки, которые служат аргументами этих функций, будут состоять только из терминалов грамматики $G_0$ и символов $\\$ $ и $E$. Далее, $\gamma$ обозначает $E$ или пустую цепочку, $\boldsymbol b$ и $\boldsymbol c$ — терминалы или $\\$ $.

$f(\boldsymbol b \gamma, \boldsymbol c) =$ если $\boldsymbol b \lessdot \boldsymbol c$ или $\boldsymbol b \doteq \boldsymbol c$, то **перенос**,

&nbsp;&nbsp;&nbsp;&nbsp;иначе если $\boldsymbol b \gtrdot \boldsymbol c$, то **свертка**,

&nbsp;&nbsp;&nbsp;&nbsp;иначе если $\boldsymbol b \doteq \\$ $, $\gamma \doteq E$ и $\boldsymbol c \doteq \\$ $, то **допуск**,

&nbsp;&nbsp;&nbsp;&nbsp;иначе **ошибка**.

$g(\boldsymbol b \gamma \boldsymbol a, x) = 6$, если $\boldsymbol b \lessdot \boldsymbol a$,

$g(\boldsymbol b E * E, x) = 3$, если $\boldsymbol b \lessdot *$,

$g(\boldsymbol b E+E, x) = 1$, если $\boldsymbol b \lessdot +$,

$g(\boldsymbol b \gamma (E), x) = 5$, если $\boldsymbol b \lessdot ($,

$g(\boldsymbol a, x) =$ **ошибка** в остальных случаях.

Таким образом, для входной цепочки $(\boldsymbol a + \boldsymbol a) * \boldsymbol a$ алгоритм сделает такую последовательность шагов:

![](https://sun9-north.userapi.com/sun9-83/s/v1/ig2/7sid5lnefWYjK1ISSoQrOVMa39-1MMbm0oZB2m9G-1fGCxggx7q7D8SjJxzQuU5ZfjvzHgKBAp7CfPRiNUx0mZnx.jpg?size=366x775&quality=96&type=album)

Можно убедиться в том, что 661563 действительно остовный правый разбор цепочки $(\boldsymbol a + \boldsymbol a) * \boldsymbol a$ в грамматике $G_{0s}$. Этот остовный разбор цепочки $(\boldsymbol a + \boldsymbol a) * \boldsymbol a$ можно представить в виде дерева.

**Пример 2** представляет собой частный случай метода, работающего для многих грамматик, особенно для тех, которые определяют языки, являющиеся множествами арифметических выражений. Этот метод включает построение новой грамматики, получаемой из старой грамматики заменой всех нетерминалов одним нетерминалом и устранением цепных правил. Для грамматики операторного предшествования всегда можно с помощью алгоритма типа «перенос-свертка» найти один разбор для каждой входной цепочки.

## 4. Практическая часть

### 4.1. Эвристический метод нахождения отношений операторного предшествования

Для грамматик математических выражений, наподобие $G_0$, можно использовать следующий эвристический метод для создания корректного множества отношений операторного предшествования.

1. Если оператор $\theta_1$ имеет более высокий приоритет, чем оператор $\theta_2$, определим, что $\theta_1 \gtrdot \theta_2$ и $\theta_2 \lessdot \theta_1$. Например, если оператор $ \ast $ имеет более высокий приоритет, чем оператор $+$, то $ \ast \gtrdot + $ и $ + \lessdot \ast$. Эти отношения гарантируют, что при получении выражения вида $E + E * E + E$ основой является $E * E$, и именно $E * E$ будет свернуто первым.
2. Если $\theta_1$ и $\theta_2$ представляют собой операторы равного приоритета (это может быть один и тот же оператор), то устанавливаем, что $\theta_1 \gtrdot \theta_2$ и $\theta_2 \gtrdot \theta_1$, если операторы лево-ассоциативны, и $\theta_1 \lessdot \theta_2$ и $\theta_2 \lessdot \theta_1$, в случае если операторы право-ассоциативны. Например, для лево-ассоциативных операторов $+$ и $-$ устанавливаем, что $+ \gtrdot -$, и $- \gtrdot +$. Для право-ассоциативного оператора возведения в степень ^ (такого оператора в грамматике $G_0$ нет, но его можно включить с наивысшим приоритетом) следует принять, что ^ $\lessdot$ ^. Такие отношения гарантируют, что в выражении $E - E + E$ основой является $E - E$, а в выражении $E$ ^ $E$ ^ $E$ — основой является последнее подвыражение $E$ ^ $E$.
3. Для всех операторов $\theta$ определяем отношения $\theta \lessdot \boldsymbol a$, $\boldsymbol a \gtrdot \theta$, $\theta \lessdot ($, $( \lessdot \theta$, $) \gtrdot \theta$, $\theta \gtrdot \$$ и $\$ \lessdot \theta$. Кроме того, считаем, что $( \doteq )$, $ \\$ \lessdot ( $, $ \\$ \lessdot \boldsymbol a $, $ ( \lessdot ( $, $ \boldsymbol a \gtrdot \\$ $, $ ) \gtrdot \\$ $, $ ( \lessdot \boldsymbol a $, $ \boldsymbol a \gtrdot ) $, $ ) \gtrdot ) $. Эти правила гарантируют, что и $\boldsymbol a$, и $(E)$ будут свернуты $E$. Кроме того, $\\$ $ служит как левым, так и правым маркером конца строки, что заставляет основы находиться между ними.
4. Если грамматика содержит унарный префиксный оператор (например, логическое отрицание $\sim$ для логических выражений), который не имеет бинарного аналога, то $\theta \lessdot \sim$ для любого оператора $\theta$, независимо от того, унарный он или бинарный. Кроме того, $\sim \gtrdot \theta$, если $\sim$ имеет более высокий приоритет, чем $\theta$, и $\sim \lessdot \theta$ в противном случае. Например, если $\sim$ имеет более высокий приоритет, чем логическое умножение $\\& $, и $\\& $ — лево-ассоциативный оператор, то в соответствии с приведенными правилами выражение $E \\& \sim E \\& E$ должно быть сгруппировано как $(E\\&(\sim E))\\&E$. Правила для постфиксного унарного оператора аналогичны рассмотренным правилам. Ситуация изменяется при рассмотрении операторов типа знака «минус», который может использоваться и как унарный префиксный оператор, и как бинарный инфиксный. Наилучшим решением этой проблемы было бы распознавание типа оператора лексическим анализатором и использование им разных токенов для бинарного и унарного минусов.

### 4.2. Обработка и нейтрализация ошибок при синтаксическом анализе операторного предшествования

Для каждой пустой клетки матрицы отношений операторного предшествования необходимо определить подпрограмму обработки и нейтрализации ошибок; одна и та же подпрограмма может использоваться в нескольких местах. Для матрицы отношений операторного предшествования из примера 1 можно предложить следующие подпрограммы.

> Подпрограмма $e_1$
Причина ошибки: отсутствует выражение в целом.
Действие анализатора: вставить операнд во входной поток.
Сообщение об ошибке: пропущен операнд.
> 

> Подпрограмма $e_2$
Причина ошибки: выражение начинается с правой скобки.
Действие анализатора: удалить правую скобку из входного потока.
Сообщение об ошибке: несбалансированная правая скобка.
> 

> Подпрограмма $e_3$
Причина ошибки: операнд или правая скобка следует за операндом или левой скобкой.
Действие анализатора: вставить знак операции (например, $+$) во входной поток.
Сообщение об ошибке: пропущен оператор.
> 

> Подпрограмма $e_4$
Причина ошибки: выражение завершается левой скобкой.
Действие анализатора: вытолкнуть левую скобку из стека.
Сообщение об ошибке: пропущена правая скобка.
> 

При таком механизме обработки и нейтрализации ошибок матрица отношений операторного предшествования из примера 1 примет следующий вид

![](https://sun9-west.userapi.com/sun9-15/s/v1/ig2/qoKOE0L2WWv3a16B5rtDgq8rY8ZIpxVuq2KIowjWW6qfEAMLKBWNfOzNWl9T6iYZGkempKlrUChyb1F-jMbl5Lwy.jpg?size=418x411&quality=96&type=album)

Возможны и другие ошибки, которые возникают тогда, когда основа обнаружена, но не существует правила вывода с правой частью, соответствующей основе. Обработка таких ошибок требует творческого подхода.

### 4.3. Пример выполнения лабораторной работы

Рассматривается грамматика логических выражений, правила вывода которой в BNF имеют вид:

```cpp
<высказывание> ::= <импликация>
	| <высказывание> "=" <импликация>
<импликация> ::= <дизъюнкция>
	| <импликация> ">" <дизъюнкция>
<дизъюнкция> ::= <конъюнкция>
	| <дизъюнкция> "|" <конъюнкция>
<конъюнкция> ::= <множитель>
	| <конъюнкция> "&"<множитель>
<множитель> ::= "~"<множитель>
	| "("<высказывание> ")"
	| <атом>
<атом> ::= ["A"-"Z", "a"-"z", "0", "1"]
```

Последовательность операции "=", "> ", "|", "&" выполняется слева направо, последовательность операций "\~" выполняется справа налево. Старшинство операций определяется следующим списком: "\~" (имеет наивысшее старшинство), "&", "|", ">", "=". Программа синтаксического анализатора операторного предшествования может иметь такой вид:

```pascal
PROGRAM OperatorPrecedencePparsing;
// Прототип этой программы создан еще в 1988 году

{$APPTYPE CONSOLE}

uses
	SysUtils;

CONST
	marker = '$';
	blank = ' ';
	max = 1000;
	error_msg : array['1'..'4'] of string = (
		'отсутствует операнд.',
		'несбалансированная правая скобка.',
		'отсутствует оператор.',
		'отсутствует правая скобка.' );
TYPE
// Терминальные символы грамматики
	symbol = (_atom, _not, _and, _or, _imp, _equ, _lpar, _rpar, _doll);
VAR
// Матрица отношений операторного предшествования
	matrix : ARRAY[symbol, symbol] OF char = (
//     | atm not and or imp equ lp rp dol
// ----+----------------------------------------
{ atm  | } ('3','>','>','>','>','>','3','>','>'),
{ not  | } ('<','<','>','>','>','>','<','>','>'),
{ and  | } ('<','<','>','>','>','>','<','>','>'),
{ or   | } ('<','<','<','>','>','>','<','>','>'),
{ imp  | } ('<','<','<','<','>','>','<','>','>'),
{ equ  | } ('<','<','<','<','<','>','<','>','>'),
{ lp   | } ('<','<','<','<','<','<','<','=','4'),
{ rp   | } ('3','>','>','>','>','>','3','>','>'),
{ dol  | } ('<','<','<','<','<','<','<','2','1') );
	s : ARRAY[0..max] OF char; // Стек разбора
	t : integer; // Указатель (индекс) вершины стека
	symbols : ARRAY[char] OF symbol;
	ch : char;
	flag, done : boolean;
	i, n : integer;
	prn : ARRAY[1..max] OF char;

PROCEDURE getch;
BEGIN
	REPEAT
		read(ch)
	UNTIL ch > blank;
END; // OF PROCEDURE 'getch'

PROCEDURE gen_prn(c: char);
BEGIN
	IF NOT (c IN ['(',')']) THEN
	BEGIN
		inc(n);
		prn[n] := c
	END
END; // OF PROCEDURE 'gen_prn'

BEGIN
// Инициализация матрицы операторного предшествования 'matrix'
	FOR ch := chr(0) TO chr(255) DO
		IF ch IN ['A'..'Z','a'..'z','0','1'] THEN symbols[ch] := _atom
		ELSE
			CASE ch OF
			'~' : symbols[ch] := _not;
			'&' : symbols[ch] := _and;
			'|' : symbols[ch] := _or;
			'>' : symbols[ch] := _imp;
			'=' : symbols[ch] := _equ;
			'(' : symbols[ch] := _lpar;
			')' : symbols[ch] := _rpar;
			'$' : symbols[ch] := _doll;
			ELSE // Иначе
				symbols[ch] := _doll;
			END; // CASE

	done := false;
	flag := false;
	REPEAT
		writeln('ВВЕДИТЕ ИНФИКСНОЕ ВЫРАЖЕНИЕ(в конце выражения ''$''; только
		n := 0;
		getch;
		IF ch = marker THEN done := true
		ELSE
		BEGIN
////////////////////////////////////////////////////////////
// Начало 'operator precedence parsing algorithm'
			s[0] := marker;
			t := 0;
			WHILE (t > 0) OR (ch <> marker) DO
			BEGIN
				CASE matrix[symbols[s[t]], symbols[ch]] OF
				'<', '=' :
				BEGIN // Перенос
					inc(t);
					s[t] := ch;
					getch;
				END;
				'>' :
				BEGIN // Свертка
					REPEAT
						gen_prn(s[t]);
						dec(t);
					UNTIL matrix[symbols[s[t]], symbols[s[t+1]]] = '<'
				END;
				ELSE // Иначе
				BEGIN
					writeln('ОШИБКА: ' + error_msg[matrix[symbols[s[t]], symbols[ch]]]);
					readln;
					flag := true;
					break; // Реализация панического анализатора
				END;
				END; // CASE
			END; // WHILE
// Конец 'operator precedence parsing algorithm'
////////////////////////////////////////////////////////////
			IF flag THEN flag := false
			ELSE
			BEGIN
				write('ПОСТФИКСНАЯ ЗАПИСЬ: ');
				FOR i := 1 TO n DO write(prn[i]);
				writeln
			END; // ELSE
		END; // ELSE
	UNTIL done;
	readln;
END. // OF PROGRAM OperatorPrecedenceParser
```

Недостатком программы является то, что в ней обнаруживаются не все синтаксические ошибки. Достоинством программы является то, что в процессе синтаксического анализа выполняется преобразование инфиксного логического выражения в обратную польскую нотацию, т. е. реализуется синтаксически управляемый перевод.

## 5. Варианты заданий на лабораторную работу

Реализовать синтаксический анализатор операторного предшествования и синтаксически управляемый перевод инфиксного выражения в обратную польскую нотацию для грамматики выражений из лабораторной работы № 3.

## 6. Порядок выполнения работы

1. Ознакомиться с основными понятиями и определениями, лежащими в основе синтаксического анализа операторного предшествования.
2. Изучить алгоритм синтаксического анализа операторного предшествования.
3. Подготовить матрицу отношений операторного предшествования для предложенной грамматики.
4. Сформулировать синтаксически управляемые определения для перевода инфиксного выражения в обратную польскую нотацию.
5. Разработать, тестировать и отладить программу синтаксического анализа для предложенной грамматики.
6. Подготовить отчет о проделанной работе.
7. Подготовить ответы на контрольные вопросы.

## 7. Требования к отчету

Отчет по лабораторной работе выполняется в электронном виде и должен включать:

1. Идентификатор группы, имя и фамилию студента, дату выполнения работы.
2. Название лабораторной работы.
3. Описание задания – постановку задач, подлежащих выполнению в процессе лабораторной работы.
4. Текст программы, в которой решаются поставленные задачи.
5. Набор тестов и ожидаемые результаты для проверки правильности программы.
6. Результаты выполнения программы.
7. Анализ результатов и краткие выводы по работе.
8. Список дополнительной использованной литературы или дополнительных использованных электронных ресурсов.

## 8. Контрольные вопросы

1. Что такое операторная грамматика?
2. Что такое грамматика операторного предшествования?
3. Как определяются отношения операторного предшествования?
4. Как выделяется основа в процессе синтаксического разбора операторного предшествования?
5. Какие виды синтаксически ошибок не обнаруживаются в предложенном примере?
6. Какие действия надо предпринять для обнаружения всех синтаксических ошибок в предложенном примере?
7. Как сформулировать синтаксически управляемые определения для перевода инфиксного выражения в последовательность команд стековой машины?
8. Как сформулировать синтаксически управляемые определения для перевода инфиксного выражения в абстрактное синтаксическое дерево?

## 9. Рекомендуемая литература

1. Ахо А., Ульман Дж., Сети Р. Компиляторы: принципы, технологии и инструменты. — М.: Вильямс, 2001. [Параграф 4.6. Синтаксический анализ приоритета операторов]
2. Ахо А., Ульман Дж. Теория синтаксического анализа, перевода и компиляции: В 2-х томах. Т.1.: Синтаксический анализ. — М.: Мир, 1978. [Пункт 5.4.3. Грамматики операторного предшествования]
3. Ахо А., Ульман Дж. Теория синтаксического анализа, перевода и компиляции: В 2-х томах. Т.2.: Компиляция. — М.: Мир, 1978. [Пункт 9.2.1. Простые синтаксически управляемые переводы]
